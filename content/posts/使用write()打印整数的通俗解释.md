

直接上代码：
```C
void ft_putnbr(int n)
{
    char digit;
    
    if (n >= 10)
        ft_putnbr(n / 10);
    digit = n % 10 + '0';
    write(1, &digit, 1);
}
```
这个可以实现用write来打整型数字。

用到两个原理：
1，0-9的整数+字符，得到的结果是整数+字符对应的ascii码，两者之和的ASCII码对应的字符。
比如说，‘0’的ASCII码是48，那如果待转换数字是5。我用5+'0'，得到的就是53，53是0的ascii码48的后五位，自然就是字符‘5’。
总结一下，如果n=5，那么char c = n + '0'，c就是‘5’，easy peasy, right？

**以下算法涉及递归**

2，对于大于9的数字，我们必须把每一位拆出来。比如拆最高位，就必须不停的 / 10，去把它变成个位数。比如253，/10，变成25，再/10，变成2，就得到最高位；那怎么拿到第二位呢，那只要%10，253 % 10 = 53，这就拿到了53，再以此类推拿5。如果直接写，循环会变的非常麻烦。这个时候递归算法就可以很简单的解决问题。

在上面这个函数当中，如果n>=10，那就把n/10，作为参数再调用它自身，直到n<10，我们就得到了首位；首位 % 10，还是它自己，所以+'0'，就打印出了第一个字符。然后函数执行就会回到上一层的调用。比如还是253举例，当给到这个函数里之后，/10，调用自身一次，此时参数是25；依然大于十，又调用一次，此时得到2，2 % 10 + ‘0’ = ‘2’，但此时还没执行完呢，函数要回到上一层，上一层是25，那我们要获得5，也即是个位，那也是 25 % 10，得到5，5+‘0’ = ‘5’；最后回到最外层，就是251本身，此时我们还剩1没有打，依然只要 251 % 10 + ‘0’ = ‘1’，这样就按顺序完成了打印。